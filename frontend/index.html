<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>DNAiOS Architecture Studio v4.7 - Enhanced</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/editor/editor.main.min.css"/>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  :root {
    --primary: #667eea;
    --primary-dark: #5568d3;
    --secondary: #764ba2;
    --bg-main: #f8fafc;
    --bg-card: #ffffff;
    --text-dark: #0f172a;
    --text-medium: #475569;
    --text-light: #94a3b8;
    --border: #e2e8f0;
    --shadow-sm: 0 1px 3px rgba(0,0,0,.08);
    --shadow-md: 0 4px 12px rgba(0,0,0,.1);
    --shadow-lg: 0 10px 24px rgba(0,0,0,.12);
    --radius: 12px;
  }
  
  [data-theme="dark"] {
    --primary: #818cf8;
    --primary-dark: #6366f1;
    --secondary: #a78bfa;
    --bg-main: #1a1f2e;
    --bg-card: #242938;
    --text-dark: #f8fafc;
    --text-medium: #e2e8f0;
    --text-light: #cbd5e1;
    --border: #3f4556;
    --shadow-sm: 0 1px 3px rgba(0,0,0,.3);
    --shadow-md: 0 4px 12px rgba(0,0,0,.4);
    --shadow-lg: 0 10px 24px rgba(0,0,0,.5);
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", Arial, sans-serif;
    background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
    height: 100vh;
    overflow: hidden;
    color: var(--text-dark);
    transition: background .3s, color .3s;
  }
  
  .header {
    background: var(--bg-card);
    padding: 16px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: var(--shadow-md);
    z-index: 1000;
    position: relative;
  }
  
  .brand {
    display: flex;
    align-items: center;
    gap: 12px;
    font-weight: 800;
    font-size: 20px;
  }
  
  .brand-icon { font-size: 28px; }
  
  .brand-text {
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  .toolbar {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  
  .btn {
    border: none;
    border-radius: 10px;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    padding: 10px 16px;
    display: flex;
    gap: 8px;
    align-items: center;
    transition: all .2s cubic-bezier(.4,0,.2,1);
    white-space: nowrap;
  }
  
  .btn-primary {
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    color: white;
    box-shadow: var(--shadow-sm);
  }
  
  .btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(102,126,234,.4);
  }
  
  .btn-primary:active { transform: translateY(0); }
  .btn-primary:disabled {
    opacity: .6;
    cursor: not-allowed;
    transform: none;
  }
  
  .btn-secondary {
    background: var(--bg-card);
    border: 2px solid var(--border);
    color: var(--text-dark);
  }
  
  .btn-secondary:hover {
    border-color: var(--primary);
    background: #f8f9ff;
  }
  
  .search-box {
    position: relative;
  }
  
  .search-input {
    border: 2px solid var(--border);
    border-radius: 10px;
    padding: 10px 14px 10px 38px;
    background: var(--bg-card);
    color: var(--text-dark);
    font-size: 14px;
    width: 220px;
    transition: all .2s;
  }
  
  .search-input:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(102,126,234,.1);
    width: 280px;
  }
  
  .search-icon {
    position: absolute;
    left: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-light);
    font-size: 16px;
  }
  
  .search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    margin-top: 8px;
    background: var(--bg-card);
    border-radius: 10px;
    box-shadow: var(--shadow-lg);
    max-height: 300px;
    overflow-y: auto;
    display: none;
    z-index: 1001;
  }
  
  .search-results.active { display: block; }
  
  .search-result {
    padding: 10px 14px;
    cursor: pointer;
    border-bottom: 1px solid var(--border);
    transition: background .15s;
  }
  
  .search-result:hover { background: var(--bg-main); }
  .search-result:last-child { border-bottom: none; }
  
  .search-result-title {
    font-weight: 600;
    color: var(--text-dark);
  }
  
  .search-result-path {
    font-size: 12px;
    color: var(--text-light);
    margin-top: 2px;
  }
  
  .select-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  select, .checkbox-label {
    border: 2px solid var(--border);
    border-radius: 10px;
    padding: 10px 14px;
    background: var(--bg-card);
    color: var(--text-dark);
    font-weight: 600;
    cursor: pointer;
    transition: all .2s;
  }
  
  .checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    user-select: none;
  }
  
  select:hover, .checkbox-label:hover { border-color: var(--primary); }
  select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(102,126,234,.1);
  }
  
  input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
  }
  
  .main {
    display: flex;
    height: calc(100vh - 68px);
  }
  
  .sidebar {
    width: 340px;
    background: var(--bg-card);
    box-shadow: 2px 0 12px rgba(0,0,0,.06);
    overflow-y: auto;
    overflow-x: hidden;
  }
  
  .section {
    padding: 20px;
    border-bottom: 1px solid var(--border);
  }
  
  .section-title {
    font-size: 11px;
    font-weight: 800;
    color: var(--primary);
    letter-spacing: .8px;
    text-transform: uppercase;
    margin-bottom: 14px;
  }
  
  .folder-item, .file-item {
    padding: 6px 12px;
    border-radius: 6px;
    margin: 2px 0;
    cursor: pointer;
    transition: all .15s;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .folder-item {
    font-weight: 600;
    color: var(--text-dark);
  }
  
  .folder-item:hover, .file-item:hover {
    background: var(--bg-main);
    transform: translateX(2px);
  }
  
  .folder-icon {
    font-size: 16px;
    flex-shrink: 0;
  }
  
  .folder-name, .file-name {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  .folder-children {
    margin-left: 20px;
    border-left: 2px solid var(--border);
    padding-left: 8px;
  }
  
  .folder-collapsed > .folder-children {
    display: none;
  }
  
  .file-item {
    color: var(--text-medium);
    font-weight: 500;
  }
  
  .node-detail {
    font-size: 13px;
    color: var(--text-medium);
    margin-bottom: 10px;
    line-height: 1.6;
  }
  
  .node-detail strong {
    color: var(--text-dark);
    font-weight: 700;
  }
  
  .chip-container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
  }
  
  .chip {
    background: var(--bg-main);
    border: 1px solid var(--border);
    color: var(--primary);
    border-radius: 999px;
    padding: 4px 12px;
    font-size: 12px;
    cursor: pointer;
    transition: all .15s;
    font-weight: 600;
  }
  
  .chip:hover {
    background: var(--primary);
    color: white;
    transform: translateY(-1px);
  }
  
  .canvas {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: var(--bg-main);
  }
  
  #viewport {
    position: absolute;
    inset: 0;
    transform-origin: 0 0;
  }
  
  #edgesSvg {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 1;
    overflow: visible;
  }
  
  .lanes-container {
    position: absolute;
    inset: 0;
    z-index: 0;
    pointer-events: none;
  }
  
  .lane {
    position: absolute;
    left: 0;
    right: 0;
    background: rgba(102,126,234,.06);
    border-top: 1px dashed rgba(102,126,234,.2);
    border-bottom: 1px dashed rgba(102,126,234,.2);
    font-weight: 700;
    color: var(--text-medium);
    display: flex;
    align-items: center;
    padding-left: 16px;
    font-size: 14px;
  }
  
  .nodes-container {
    position: absolute;
    inset: 0;
    z-index: 2;
  }
  
  .minimap {
    position: absolute;
    bottom: 24px;
    right: 24px;
    width: 200px;
    height: 150px;
    background: var(--bg-card);
    border-radius: var(--radius);
    box-shadow: var(--shadow-lg);
    border: 2px solid var(--border);
    z-index: 100;
    overflow: hidden;
  }
  
  .minimap svg {
    width: 100%;
    height: 100%;
  }
  
  .minimap-viewport {
    fill: rgba(102,126,234,.2);
    stroke: var(--primary);
    stroke-width: 2;
    cursor: move;
  }
  
  .minimap-node {
    cursor: pointer;
  }
  
  .legend {
    position: absolute;
    top: 24px;
    left: 24px;
    background: var(--bg-card);
    border-radius: var(--radius);
    box-shadow: var(--shadow-md);
    padding: 14px 16px;
    border: 2px solid var(--border);
    z-index: 100;
    min-width: 180px;
  }
  
  .legend-title {
    font-size: 11px;
    font-weight: 800;
    color: var(--primary);
    letter-spacing: .8px;
    text-transform: uppercase;
    margin-bottom: 10px;
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    font-size: 13px;
    color: var(--text-medium);
  }
  
  .legend-line {
    width: 30px;
    height: 3px;
    border-radius: 2px;
  }
  
  .legend-imports { background: #60a5fa; }
  .legend-defines { background: #22c55e; }
  .legend-calls { background: #fde047; }
  .legend-external { background: #f87171; }
  
  .card {
    position: absolute;
    background: var(--bg-card);
    border-radius: var(--radius);
    box-shadow: var(--shadow-md);
    min-width: 260px;
    max-width: 360px;
    user-select: none;
    cursor: move;
    transition: all .2s cubic-bezier(.4,0,.2,1);
  }
  
  .card:hover {
    box-shadow: var(--shadow-lg);
    transform: scale(1.02);
  }
  
  .card.selected {
    box-shadow: 0 0 0 3px var(--primary), var(--shadow-lg);
  }
  
  .card.faded { opacity: .5; }
  .card.highlighted {
    box-shadow: 0 0 0 3px #f59e0b, var(--shadow-lg);
    animation: pulse 2s ease-in-out;
  }
  
  .card.complexity-low { transform: scale(0.95); }
  .card.complexity-medium { transform: scale(1.0); }
  .card.complexity-high { transform: scale(1.1); }
  .card.complexity-very-high { transform: scale(1.2); }
  
  .card:hover.complexity-low { transform: scale(0.97); }
  .card:hover.complexity-medium { transform: scale(1.02); }
  .card:hover.complexity-high { transform: scale(1.12); }
  .card:hover.complexity-very-high { transform: scale(1.22); }
  
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  
  .card-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px;
    border-bottom: 2px solid var(--border);
  }
  
  .card-icon {
    font-size: 28px;
    flex-shrink: 0;
  }
  
  .card-title {
    font-weight: 800;
    color: var(--text-dark);
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 15px;
  }
  
  .card-badge {
    padding: 4px 10px;
    border-radius: 999px;
    font-size: 10px;
    font-weight: 800;
    letter-spacing: .4px;
    text-transform: uppercase;
    flex-shrink: 0;
  }
  
  .card-body {
    padding: 14px 16px;
    color: var(--text-medium);
    font-size: 13px;
    line-height: 1.6;
    max-height: 80px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    line-clamp: 3;
    -webkit-box-orient: vertical;
    box-orient: vertical;
  }
  
  .card-stats {
    display: flex;
    gap: 14px;
    padding: 0 16px 14px;
    color: var(--text-light);
    font-size: 12px;
    flex-wrap: wrap;
  }
  
  .card-stats strong { color: var(--text-dark); }
  
  .t-agent .card-badge { background: #dcfce7; color: #166534; border: 1px solid #86efac; }
  .t-memory .card-badge { background: #ede9fe; color: #5b21b6; border: 1px solid #c4b5fd; }
  .t-rsi .card-badge { background: #fef3c7; color: #92400e; border: 1px solid #fde68a; }
  .t-haa .card-badge { background: #fee2e2; color: #991b1b; border: 1px solid #fecaca; }
  .t-data .card-badge { background: #dbeafe; color: #1e40af; border: 1px solid #bfdbfe; }
  .t-class .card-badge { background: #e0e7ff; color: #3730a3; border: 1px solid #a5b4fc; }
  .t-function .card-badge { background: #fef3c7; color: #78350f; border: 1px solid #fde047; }
  
  .zoom-controls {
    position: absolute;
    top: 24px;
    right: 24px;
    display: flex;
    gap: 8px;
    z-index: 100;
  }
  
  .zoom-btn {
    width: 44px;
    height: 44px;
    border-radius: 10px;
    background: var(--bg-card);
    border: 2px solid var(--border);
    color: var(--text-dark);
    font-size: 18px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all .2s;
    box-shadow: var(--shadow-sm);
  }
  
  .zoom-btn:hover {
    border-color: var(--primary);
    background: var(--bg-main);
  }
  
  .toast {
    position: fixed;
    top: 92px;
    right: 24px;
    background: var(--bg-card);
    border-radius: var(--radius);
    box-shadow: var(--shadow-lg);
    padding: 14px 18px;
    max-width: 400px;
    z-index: 9999;
    display: none;
    animation: slideIn .3s cubic-bezier(.4,0,.2,1);
    font-size: 14px;
    color: var(--text-dark);
    border-left: 4px solid var(--primary);
  }
  
  @keyframes slideIn {
    from { transform: translateX(400px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  .loading {
    position: fixed;
    inset: 0;
    background: rgba(15,23,42,.85);
    backdrop-filter: blur(4px);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9998;
  }
  
  .loading.active { display: flex; }
  
  .spinner {
    width: 56px;
    height: 56px;
    border: 4px solid rgba(255,255,255,.2);
    border-top-color: white;
    border-radius: 50%;
    animation: spin .8s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  input[type="file"] { display: none; }
  
  .sidebar::-webkit-scrollbar { width: 8px; }
  .sidebar::-webkit-scrollbar-track { background: var(--bg-main); }
  .sidebar::-webkit-scrollbar-thumb { 
    background: var(--border); 
    border-radius: 4px;
  }
  .sidebar::-webkit-scrollbar-thumb:hover { background: var(--text-light); }
  
  .search-results::-webkit-scrollbar { width: 6px; }
  .search-results::-webkit-scrollbar-track { background: var(--bg-main); }
  .search-results::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  
  /* Code Editor Modal */
  .code-modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(4px);
    z-index: 10000;
    display: none;
    align-items: center;
    justify-content: center;
  }
  
  .code-modal.active { display: flex; }
  
  .code-modal-content {
    background: var(--bg-card);
    border-radius: var(--radius);
    width: 90%;
    height: 85%;
    max-width: 1400px;
    display: flex;
    flex-direction: column;
    box-shadow: var(--shadow-lg);
    border: 2px solid var(--border);
  }
  
  .code-modal-header {
    padding: 20px 24px;
    border-bottom: 2px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .code-modal-title {
    font-size: 18px;
    font-weight: 800;
    color: var(--text-dark);
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .code-modal-actions {
    display: flex;
    gap: 8px;
  }
  
  .code-modal-body {
    flex: 1;
    display: flex;
    overflow: hidden;
  }
  
  .code-editor-container {
    flex: 1;
    position: relative;
  }
  
  .ai-panel {
    width: 400px;
    border-left: 2px solid var(--border);
    display: flex;
    flex-direction: column;
    background: var(--bg-main);
  }
  
  .ai-panel.hidden { display: none; }
  
  .ai-panel-header {
    padding: 16px;
    border-bottom: 2px solid var(--border);
    background: var(--bg-card);
  }
  
  .ai-panel-title {
    font-size: 14px;
    font-weight: 800;
    color: var(--primary);
    text-transform: uppercase;
    letter-spacing: 0.8px;
    margin-bottom: 12px;
  }
  
  .ai-provider-select {
    width: 100%;
    padding: 8px 12px;
    border: 2px solid var(--border);
    border-radius: 8px;
    background: var(--bg-card);
    color: var(--text-dark);
    font-weight: 600;
    margin-bottom: 8px;
  }
  
  .ai-api-key-input {
    width: 100%;
    padding: 8px 12px;
    border: 2px solid var(--border);
    border-radius: 8px;
    background: var(--bg-card);
    color: var(--text-dark);
    font-size: 12px;
    font-family: monospace;
  }
  
  .ai-panel-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
  }
  
  .ai-action-btn {
    width: 100%;
    padding: 10px 16px;
    margin-bottom: 8px;
    border: 2px solid var(--border);
    border-radius: 8px;
    background: var(--bg-card);
    color: var(--text-dark);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .ai-action-btn:hover {
    border-color: var(--primary);
    background: var(--primary);
    color: white;
  }
  
  .ai-response {
    background: var(--bg-card);
    border: 2px solid var(--border);
    border-radius: 8px;
    padding: 12px;
    margin-top: 12px;
    font-size: 13px;
    line-height: 1.6;
    color: var(--text-dark);
    max-height: 400px;
    overflow-y: auto;
  }
  
  .ai-loading {
    display: none;
    text-align: center;
    padding: 20px;
    color: var(--text-medium);
  }
  
  .ai-loading.active { display: block; }
  
  .code-stats {
    padding: 12px 16px;
    border-top: 2px solid var(--border);
    background: var(--bg-card);
    display: flex;
    gap: 20px;
    font-size: 12px;
    color: var(--text-medium);
  }
  
  .code-stat strong {
    color: var(--text-dark);
    font-weight: 700;
  }
</style>
</head>
<body>
<!-- Monaco container -->
<div id="monaco-panel" style="display:none;"></div>

<!-- Load your module -->
<script src="monaco.js"></script>
<script>
  // After you receive the analyzer JSON:
  // data.file_contents = { "A/B.py": "code...", ... }
  // Example hook:
  async function onAnalyzerResponse(data) {
    MonacoUI.mount('monaco-panel');               // 1) attach UI
    MonacoUI.loadFiles(data.file_contents || {}); // 2) cache files
    // Later, when user clicks a node:
    // MonacoUI.open(node.path);
  }
</script>

<header class="header">
  <div class="brand">
    <span class="brand-icon">üß¨</span>
    <span class="brand-text">DNAiOS Architecture Studio v4.7</span>
  </div>
  <div class="toolbar">
    <button class="btn btn-primary" id="uploadBtn" onclick="triggerUpload()">
      üìÅ Upload
    </button>
    <input id="fileInput" type="file" accept=".zip,.py" onchange="handleUpload(event)"/>
    
    <div class="search-box">
      <span class="search-icon">üîç</span>
      <input 
        type="text" 
        class="search-input" 
        id="searchInput" 
        placeholder="Search modules..."
        oninput="handleSearch(this.value)"
        onfocus="showSearchResults()"
        onblur="setTimeout(hideSearchResults, 200)"
      />
      <div class="search-results" id="searchResults"></div>
    </div>
    
    <label class="checkbox-label">
      <input type="checkbox" id="symbolLevel" onchange="updateSettings()"/>
      <span>Symbols</span>
    </label>
    
    <div class="select-wrapper">
      <label style="font-weight:700;color:var(--text-dark)">View:</label>
      <select id="viewMode" onchange="switchView(this.value)">
        <option value="hierarchy">Hierarchy (Dependency)</option>
        <option value="folderhierarchy">Hierarchy (Folders)</option>
        <option value="grid">Grid</option>
        <option value="force">Force</option>
        <option value="swimlanes">Swimlanes</option>
        <option value="radial">Radial</option>
        <option value="foldertree">Folder Tree</option>
      </select>
    </div>
    
    <div class="select-wrapper" id="orientationWrapper" style="display:none;">
      <label style="font-weight:700;color:var(--text-dark)">Orient:</label>
      <select id="orientation" onchange="updateOrientation(this.value)">
        <option value="vertical">Vertical</option>
        <option value="horizontal">Horizontal</option>
      </select>
    </div>
    
    <button class="btn btn-secondary" onclick="toggleTheme()" id="themeBtn">üåô</button>
    <button class="btn btn-secondary" onclick="exportScreenshot()" title="Export PNG">üì∏ PNG</button>
    <button class="btn btn-secondary" onclick="exportGraph()">üíæ JSON</button>
    <button class="btn btn-secondary" onclick="generateAIPrompt()" title="Generate AI Prompt">ü§ñ AI</button>
    <button class="btn btn-secondary" onclick="copyPermalink()" title="Copy link">üîó</button>
  </div>
</header>

<main class="main">
  <aside class="sidebar">
    <div class="section">
      <div class="section-title">üìÇ Folder Structure</div>
      <div id="folderTree">Upload a Python project (.zip) or file (.py) to begin‚Ä¶</div>
    </div>
    <div class="section">
      <div class="section-title">Selected Module</div>
      <div id="nodeDetails">Click a node to view details.</div>
    </div>
  </aside>

  <section class="canvas" id="canvas">
    <div id="viewport">
      <svg id="edgesSvg">
        <defs>
          <marker id="arrow-imports" viewBox="0 0 10 10" refX="10" refY="5" 
            markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M0 0 L10 5 L0 10 Z" fill="#60a5fa" opacity=".9"></path>
          </marker>
          <marker id="arrow-defines" viewBox="0 0 10 10" refX="10" refY="5" 
            markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M0 0 L10 5 L0 10 Z" fill="#22c55e" opacity=".9"></path>
          </marker>
          <marker id="arrow-calls" viewBox="0 0 10 10" refX="10" refY="5" 
            markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M0 0 L10 5 L0 10 Z" fill="#fde047" opacity=".9"></path>
          </marker>
          <marker id="arrow-external" viewBox="0 0 10 10" refX="10" refY="5" 
            markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M0 0 L10 5 L0 10 Z" fill="#f87171" opacity=".9"></path>
          </marker>
        </defs>
      </svg>
      <div class="lanes-container" id="lanes"></div>
      <div class="nodes-container" id="nodes"></div>
    </div>
    
    <div class="legend">
      <div class="legend-title">Edge Types</div>
      <div class="legend-item">
        <div class="legend-line legend-imports"></div>
        <span>Imports</span>
      </div>
      <div class="legend-item">
        <div class="legend-line legend-defines"></div>
        <span>Defines</span>
      </div>
      <div class="legend-item">
        <div class="legend-line legend-calls"></div>
        <span>Calls</span>
      </div>
      <div class="legend-item">
        <div class="legend-line legend-external"></div>
        <span>External</span>
      </div>
    </div>
    
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomIn()" title="Zoom In (+)">+</button>
      <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out (-)">‚àí</button>
      <button class="zoom-btn" onclick="fitToScreen()" title="Fit to Screen (0)">‚ä°</button>
    </div>
    
    <div class="minimap" id="minimap">
      <svg id="minimapSvg"></svg>
    </div>
  </section>
</main>

<div id="toast" class="toast"></div>
<div class="loading" id="loading">
  <div class="spinner"></div>
</div>

<!-- Code Editor Modal -->
<div class="code-modal" id="codeModal">
  <div class="code-modal-content">
    <div class="code-modal-header">
      <div class="code-modal-title">
        <span>üìù</span>
        <span id="codeModalFileName">Code Viewer</span>
      </div>
      <div class="code-modal-actions">
        <button class="btn btn-secondary" onclick="toggleAIPanel()">ü§ñ AI Assistant</button>
        <button class="btn btn-secondary" onclick="copyCode()">üìã Copy</button>
        <button class="btn btn-secondary" onclick="closeCodeModal()">‚úï Close</button>
      </div>
    </div>
    <div class="code-modal-body">
      <div class="code-editor-container" id="monacoContainer"></div>
      <div class="ai-panel hidden" id="aiPanel">
        <div class="ai-panel-header">
          <div class="ai-panel-title">AI Code Assistant</div>
          <select class="ai-provider-select" id="aiProvider" onchange="saveAISettings()">
            <option value="openai">OpenAI GPT-4</option>
            <option value="anthropic">Anthropic Claude</option>
            <option value="dnaios">DNAiOS AI</option>
            <option value="custom">Custom Endpoint</option>
          </select>
          <input 
            type="password" 
            class="ai-api-key-input" 
            id="aiApiKey" 
            placeholder="Enter API key..."
            onchange="saveAISettings()"
          />
        </div>
        <div class="ai-panel-body">
          <button class="ai-action-btn" onclick="analyzeCode('explain')">
            üí° Explain Code
          </button>
          <button class="ai-action-btn" onclick="analyzeCode('refactor')">
            üîß Suggest Refactoring
          </button>
          <button class="ai-action-btn" onclick="analyzeCode('bugs')">
            üêõ Find Potential Bugs
          </button>
          <button class="ai-action-btn" onclick="analyzeCode('optimize')">
            ‚ö° Optimization Tips
          </button>
          <button class="ai-action-btn" onclick="analyzeCode('document')">
            üìö Generate Documentation
          </button>
          <div class="ai-loading" id="aiLoading">
            <div class="spinner" style="width:32px;height:32px;border-width:3px;"></div>
            <div style="margin-top:12px;">Analyzing code...</div>
          </div>
          <div id="aiResponse"></div>
        </div>
      </div>
    </div>
    <div class="code-stats" id="codeStats">
      <span class="code-stat"><strong>Lines:</strong> <span id="statLines">0</span></span>
      <span class="code-stat"><strong>Language:</strong> <span id="statLang">Python</span></span>
      <span class="code-stat"><strong>Size:</strong> <span id="statSize">0 KB</span></span>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
<script>
const state = {
  nodes: [],
  edges: [],
  selectedId: null,
  uploading: false,
  viewMode: 'hierarchy',
  orientation: 'vertical',
  zoom: 1,
  viewX: 0,
  viewY: 0,
  nodeElements: new Map(),
  nodeSizes: new Map(),
  searchResults: [],
  symbolLevel: false,
  theme: 'light',
  moduleDetails: {},
  folderStructure: null,
  nodesReady: false,
  fileContents: new Map(), // Store Python file contents
  monacoEditor: null,
  currentCode: ''
};

const BACKEND_URL = 'https://dnaios-analyzer-deploy.onrender.com';
const EDGE_COLORS = {
  imports: '#60a5fa',
  defines: '#22c55e',
  calls: '#fde047',
  external: '#f87171'
};

// Monaco Editor Configuration
let monacoLoaded = false;

function initMonaco() {
  if (monacoLoaded) return Promise.resolve();
  
  return new Promise((resolve) => {
    require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }});
    require(['vs/editor/editor.main'], function() {
      monacoLoaded = true;
      resolve();
    });
  });
}

function openCodeModal(nodeId) {
  const node = state.nodes.find(n => n.id === nodeId);
  if (!node || !node.path) {
    showToast('No code file associated with this node');
    return;
  }
  
  const code = state.fileContents.get(node.path);
  if (!code) {
    showToast('Code file not found');
    return;
  }
  
  state.currentCode = code;
  document.getElementById('codeModalFileName').textContent = node.path;
  document.getElementById('codeModal').classList.add('active');
  
  // Update stats
  const lines = code.split('\n').length;
  const size = (new Blob([code]).size / 1024).toFixed(2);
  document.getElementById('statLines').textContent = lines;
  document.getElementById('statSize').textContent = size + ' KB';
  
  initMonaco().then(() => {
    if (!state.monacoEditor) {
      const container = document.getElementById('monacoContainer');
      state.monacoEditor = monaco.editor.create(container, {
        value: code,
        language: 'python',
        theme: state.theme === 'dark' ? 'vs-dark' : 'vs',
        readOnly: true,
        minimap: { enabled: true },
        scrollBeyondLastLine: false,
        fontSize: 13,
        lineNumbers: 'on',
        renderWhitespace: 'selection',
        folding: true,
        automaticLayout: true
      });
    } else {
      state.monacoEditor.setValue(code);
    }
  });
}

function closeCodeModal() {
  document.getElementById('codeModal').classList.remove('active');
}

function toggleAIPanel() {
  const panel = document.getElementById('aiPanel');
  panel.classList.toggle('hidden');
}

function copyCode() {
  if (state.currentCode) {
    navigator.clipboard.writeText(state.currentCode).then(() => {
      showToast('Code copied to clipboard!');
    }).catch(() => {
      showToast('Failed to copy code');
    });
  }
}

function saveAISettings() {
  const provider = document.getElementById('aiProvider').value;
  const apiKey = document.getElementById('aiApiKey').value;
  
  if (apiKey) {
    localStorage.setItem(`ai_${provider}_key`, apiKey);
    showToast('AI settings saved');
  }
}

function loadAISettings() {
  const provider = document.getElementById('aiProvider').value;
  const savedKey = localStorage.getItem(`ai_${provider}_key`);
  
  if (savedKey) {
    document.getElementById('aiApiKey').value = savedKey;
  } else {
    document.getElementById('aiApiKey').value = '';
  }
}

// AI Provider change handler
document.addEventListener('DOMContentLoaded', () => {
  const providerSelect = document.getElementById('aiProvider');
  if (providerSelect) {
    providerSelect.addEventListener('change', loadAISettings);
    loadAISettings();
  }
});

async function analyzeCode(analysisType) {
  const provider = document.getElementById('aiProvider').value;
  const apiKey = document.getElementById('aiApiKey').value;
  
  if (!apiKey) {
    showToast('Please enter an API key first');
    return;
  }
  
  if (!state.currentCode) {
    showToast('No code to analyze');
    return;
  }
  
  const prompts = {
    explain: 'Explain what this Python code does in detail. Break down the main functionality, key methods, and purpose.',
    refactor: 'Suggest refactoring improvements for this Python code. Focus on code quality, maintainability, and best practices.',
    bugs: 'Analyze this Python code for potential bugs, edge cases, and error-prone patterns. List any issues you find.',
    optimize: 'Suggest performance optimizations for this Python code. Focus on algorithmic improvements and efficiency.',
    document: 'Generate comprehensive documentation for this Python code including docstrings, parameter descriptions, and usage examples.'
  };
  
  const prompt = `${prompts[analysisType]}\n\n\`\`\`python\n${state.currentCode}\n\`\`\``;
  
  document.getElementById('aiLoading').classList.add('active');
  document.getElementById('aiResponse').innerHTML = '';
  
  try {
    let response;
    
    if (provider === 'openai') {
      response = await callOpenAI(apiKey, prompt);
    } else if (provider === 'anthropic') {
      response = await callAnthropic(apiKey, prompt);
    } else if (provider === 'dnaios') {
      response = await callDNAiOSAI(apiKey, prompt);
    } else {
      response = 'Custom endpoint not yet configured';
    }
    
    displayAIResponse(response);
  } catch (error) {
    displayAIResponse(`Error: ${error.message}`);
  } finally {
    document.getElementById('aiLoading').classList.remove('active');
  }
}

async function callOpenAI(apiKey, prompt) {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: 'gpt-4',
      messages: [
        { role: 'system', content: 'You are an expert Python code analyst.' },
        { role: 'user', content: prompt }
      ],
      max_tokens: 2000,
      temperature: 0.7
    })
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'OpenAI API error');
  }
  
  const data = await response.json();
  return data.choices[0].message.content;
}

async function callAnthropic(apiKey, prompt) {
  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify({
      model: 'claude-3-5-sonnet-20241022',
      max_tokens: 2000,
      messages: [
        { role: 'user', content: prompt }
      ]
    })
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'Anthropic API error');
  }
  
  const data = await response.json();
  return data.content[0].text;
}

async function callDNAiOSAI(apiKey, prompt) {
  // Placeholder for DNAiOS AI endpoint
  // Replace with your actual endpoint
  const response = await fetch('YOUR_DNAIOS_AI_ENDPOINT', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      prompt: prompt
    })
  });
  
  if (!response.ok) {
    throw new Error('DNAiOS AI endpoint error');
  }
  
  const data = await response.json();
  return data.response || data.content;
}

function displayAIResponse(response) {
  const container = document.getElementById('aiResponse');
  
  // Convert markdown-style code blocks to HTML
  let html = response
    .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre style="background:#f5f5f5;padding:12px;border-radius:6px;overflow-x:auto;"><code>$2</code></pre>')
    .replace(/`([^`]+)`/g, '<code style="background:#f5f5f5;padding:2px 6px;border-radius:4px;">$1</code>')
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
    .replace(/\n\n/g, '</p><p style="margin-top:12px;">')
    .replace(/\n/g, '<br>');
  
  container.innerHTML = `<div class="ai-response"><p>${html}</p></div>`;
}

function initTheme() {
  const savedTheme = localStorage.getItem('theme') || 
    (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
  setTheme(savedTheme);
}

function setTheme(theme) {
  state.theme = theme;
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('theme', theme);
  document.getElementById('themeBtn').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
}

function toggleTheme() {
  setTheme(state.theme === 'light' ? 'dark' : 'light');
}

function escapeHTML(str) {
  const div = document.createElement('div');
  div.textContent = str || '';
  return div.innerHTML;
}

function showToast(message) {
  const toast = document.getElementById('toast');
  toast.textContent = message;
  toast.style.display = 'block';
  setTimeout(() => { toast.style.display = 'none'; }, 3500);
}

function applyViewport() {
  const viewport = document.getElementById('viewport');
  viewport.style.transform = `translate(${state.viewX}px, ${state.viewY}px) scale(${state.zoom})`;
  updateMinimap();
}

function getComplexityClass(stats) {
  if (!stats || !stats.MaxComplexity) return '';
  const complexity = parseInt(stats.MaxComplexity);
  if (complexity <= 5) return 'complexity-low';
  if (complexity <= 10) return 'complexity-medium';
  if (complexity <= 20) return 'complexity-high';
  return 'complexity-very-high';
}

function encodeState() {
  const params = new URLSearchParams();
  params.set('view', state.viewMode);
  params.set('zoom', state.zoom.toFixed(2));
  params.set('x', Math.round(state.viewX));
  params.set('y', Math.round(state.viewY));
  if (state.selectedId) params.set('sel', state.selectedId);
  if (state.symbolLevel) params.set('symbols', '1');
  return params.toString();
}

function decodeState() {
  const params = new URLSearchParams(window.location.hash.slice(1));
  if (params.has('view')) {
    state.viewMode = params.get('view');
    document.getElementById('viewMode').value = state.viewMode;
  }
  if (params.has('zoom')) state.zoom = parseFloat(params.get('zoom'));
  if (params.has('x')) state.viewX = parseInt(params.get('x'));
  if (params.has('y')) state.viewY = parseInt(params.get('y'));
  if (params.has('symbols')) {
    state.symbolLevel = params.get('symbols') === '1';
    document.getElementById('symbolLevel').checked = state.symbolLevel;
  }
  if (params.has('sel') && state.nodes.length) {
    setTimeout(() => selectNode(params.get('sel')), 100);
  }
  applyViewport();
}

function updateURL() {
  window.location.hash = encodeState();
}

function copyPermalink() {
  const url = window.location.origin + window.location.pathname + '#' + encodeState();
  navigator.clipboard.writeText(url).then(() => {
    showToast('Shareable link copied!');
  }).catch(() => {
    showToast('Link: ' + url);
  });
}

function updateSettings() {
  state.symbolLevel = document.getElementById('symbolLevel').checked;
  updateURL();
}

function handleSearch(query) {
  if (!query.trim()) {
    state.searchResults = [];
    hideSearchResults();
    return;
  }
  
  const q = query.toLowerCase();
  state.searchResults = state.nodes
    .filter(n => 
      n.id.toLowerCase().includes(q) ||
      (n.title && n.title.toLowerCase().includes(q)) ||
      (n.path && n.path.toLowerCase().includes(q))
    )
    .slice(0, 10);
  
  renderSearchResults();
  showSearchResults();
}

function renderSearchResults() {
  const container = document.getElementById('searchResults');
  
  if (state.searchResults.length === 0) {
    container.innerHTML = '<div style="padding:14px;color:var(--text-light)">No results found</div>';
    return;
  }
  
  container.innerHTML = state.searchResults.map(node => `
    <div class="search-result" onclick="selectAndFocusNode('${node.id}')">
      <div class="search-result-title">${escapeHTML(node.title || node.id)}</div>
      <div class="search-result-path">${escapeHTML(node.kind || 'module')} ‚Ä¢ ${escapeHTML(node.path || node.id)}</div>
    </div>
  `).join('');
}

function showSearchResults() {
  if (state.searchResults.length > 0) {
    document.getElementById('searchResults').classList.add('active');
  }
}

function hideSearchResults() {
  document.getElementById('searchResults').classList.remove('active');
}

function selectAndFocusNode(id) {
  hideSearchResults();
  document.getElementById('searchInput').value = '';
  focusNode(id);
}

function triggerUpload() {
  document.getElementById('fileInput').click();
}

async function handleUpload(event) {
  const file = event.target.files[0];
  if (!file || state.uploading) return;
  
  const isZip = file.name.endsWith('.zip');
  const isPy = file.name.endsWith('.py');
  
  if (!isZip && !isPy) {
    showToast('Please upload a .zip or .py file');
    return;
  }
  
  state.uploading = true;
  const uploadBtn = document.getElementById('uploadBtn');
  const loading = document.getElementById('loading');
  uploadBtn.disabled = true;
  loading.classList.add('active');
  
  console.log('üì§ Uploading:', file.name, `(${(file.size / 1024 / 1024).toFixed(2)}MB)`);
  
  const formData = new FormData();
  if (isZip) {
    formData.append('zipfile', file);
  } else {
    formData.append('pyfile', file);
  }
  formData.append('symbol_level', state.symbolLevel ? 'true' : 'false');
  
  try {
    const response = await fetch(`${BACKEND_URL}/analyze`, {
      method: 'POST',
      body: formData
    });
    
    const graph = await response.json();
    
    if (!response.ok) {
      throw new Error(`Backend error: ${graph.detail || JSON.stringify(graph)}`);
    }
    
    if (!graph.nodes || graph.nodes.length === 0) {
      showToast('No Python modules found');
      return;
    }
    
    // Store file contents for code viewing
    state.fileContents.clear();
    if (graph.file_contents) {
      Object.entries(graph.file_contents).forEach(([path, content]) => {
        state.fileContents.set(path, content);
      });
      console.log('üìù Stored', state.fileContents.size, 'Python file contents for code viewing');
    }
    
    const knownIds = new Set(graph.nodes.map(n => n.id));
    state.nodes = graph.nodes.map(n => ({...n, x: n.x || 0, y: n.y || 0}));
    state.edges = (graph.edges || []).map(e => ({
      from: e.from || e.source,
      to: e.to || e.target,
      type: e.type || e.label || 'imports'
    })).filter(e => knownIds.has(e.from) && knownIds.has(e.to));
    
    state.moduleDetails = graph.module_details || {};
    state.folderStructure = graph.folder_structure || null;
    window.layoutDepth = graph.layout_depth || {};
    
    const meta = graph.metadata || {};
    console.log('‚úÖ Loaded:', meta.total_modules || 0, 'modules,', meta.total_symbols || 0, 'symbols,', state.edges.length, 'edges');
    
    renderGraph();
    buildFolderTree();
    decodeState();
    switchView(state.viewMode);
    fitToScreen();
    
    showToast(`Analyzed: ${meta.total_modules || 0} modules, ${state.edges.length} edges`);
    
  } catch (error) {
    console.error('‚ùå Upload failed:', error);
    showToast(`Error: ${error.message}`);
  } finally {
    state.uploading = false;
    uploadBtn.disabled = false;
    loading.classList.remove('active');
    event.target.value = '';
  }
}

function buildFolderTree() {
  const container = document.getElementById('folderTree');
  
  if (!state.folderStructure) {
    container.innerHTML = 'Upload a Python project (.zip) or file (.py) to begin‚Ä¶';
    return;
  }
  
  function renderFolder(folder, depth = 0) {
    const indent = depth * 20;
    let html = '';
    
    Object.values(folder.children || {}).forEach(child => {
      html += `
        <div class="folder-item" style="padding-left: ${indent}px" onclick="toggleFolder(event, this)">
          <span class="folder-icon">üìÅ</span>
          <span class="folder-name">${escapeHTML(child.name)}</span>
        </div>
        <div class="folder-children">
          ${renderFolder(child, depth + 1)}
        </div>
      `;
    });
    
    (folder.files || []).forEach(file => {
      html += `
        <div class="file-item" style="padding-left: ${indent + 20}px" onclick="focusNodeByPath('${escapeHTML(file.path)}')" title="${escapeHTML(file.path)}">
          <span class="folder-icon">üêç</span>
          <span class="file-name">${escapeHTML(file.name)}</span>
        </div>
      `;
    });
    
    return html;
  }
  
  container.innerHTML = renderFolder(state.folderStructure);
}

function toggleFolder(event, element) {
  event.stopPropagation();
  const children = element.nextElementSibling;
  
  if (children && children.classList.contains('folder-children')) {
    if (children.style.display === 'none') {
      children.style.display = 'block';
      element.querySelector('.folder-icon').textContent = 'üìÇ';
    } else {
      children.style.display = 'none';
      element.querySelector('.folder-icon').textContent = 'üìÅ';
    }
  }
}

function focusNodeByPath(path) {
  const node = state.nodes.find(n => n.path === path);
  if (node) {
    focusNode(node.id);
  }
}

function renderGraph() {
  const container = document.getElementById('nodes');
  container.innerHTML = '';
  state.nodeElements.clear();
  state.nodeSizes.clear();
  state.nodesReady = false; // ‚úÖ Reset ready flag
  
  state.nodes.forEach(node => {
    const card = document.createElement('div');
    const complexityClass = getComplexityClass(node.stats);
    card.className = `card t-${node.kind || node.type || 'data'} ${complexityClass}`;
    card.dataset.id = node.id;
    card.style.transform = `translate(${node.x}px, ${node.y}px)`;
    
    card.innerHTML = `
      <div class="card-header">
        <div class="card-icon">${node.icon || 'üíæ'}</div>
        <div class="card-title" title="${escapeHTML(node.id)}">${escapeHTML(node.title || node.id)}</div>
        <div class="card-badge">${escapeHTML(node.kind || node.type || 'data')}</div>
      </div>
      <div class="card-body" title="${escapeHTML(node.content || '')}">${escapeHTML(node.content || '')}</div>
      <div class="card-stats">
        ${Object.entries(node.stats || {}).map(([k, v]) => 
          `<span><strong>${escapeHTML(k)}:</strong> ${escapeHTML(v)}</span>`
        ).join('')}
      </div>
    `;
    
    container.appendChild(card);
    state.nodeElements.set(node.id, card);
    
    card.addEventListener('mousedown', e => startDrag(e, node));
    card.addEventListener('click', () => selectNode(node.id));
  });
  
  // ‚úÖ CRITICAL FIX: Double requestAnimationFrame + ready flag
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      state.nodes.forEach(node => {
        const card = state.nodeElements.get(node.id);
        if (card) {
          state.nodeSizes.set(node.id, {
            w: card.offsetWidth || 280,
            h: card.offsetHeight || 150
          });
        }
      });
      
      state.nodesReady = true; // ‚úÖ Set ready flag
      console.log('üé® Node sizes calculated:', state.nodeSizes.size);
      drawEdges();
      updateMinimap();
    });
  });
}

function drawEdges() {
  const svg = document.getElementById('edgesSvg');
  
  // ‚úÖ CRITICAL FIX: Silent early return if not ready
  if (!state.nodesReady || !state.nodes.length || !state.nodeSizes.size) {
    return; // Silently skip drawing - no warning needed
  }
  
  // Clear previous edges (keep defs)
  Array.from(svg.children).forEach(el => {
    if (el.tagName.toLowerCase() !== 'defs') el.remove();
  });
  
  console.log(`üé® Drawing ${state.edges.length} edges`);
  let drawn = 0;
  
  for (const edge of state.edges) {
    const from = state.nodes.find(n => n.id === edge.from);
    const to = state.nodes.find(n => n.id === edge.to);
    if (!from || !to) continue;
    
    const fs = state.nodeSizes.get(from.id) || { w: 280, h: 150 };
    const ts = state.nodeSizes.get(to.id) || { w: 280, h: 150 };
    
    const sx = from.x + fs.w / 2;
    const sy = from.y + fs.h / 2;
    const tx = to.x + ts.w / 2;
    const ty = to.y + ts.h / 2;
    
    const dx = tx - sx;
    const dy = ty - sy;
    const dist = Math.hypot(dx, dy);
    const k = Math.min(100, dist * 0.3);
    
    const pathStr = (Math.abs(dx) > Math.abs(dy))
      ? `M ${sx} ${sy} C ${sx + k} ${sy}, ${tx - k} ${ty}, ${tx} ${ty}`
      : `M ${sx} ${sy} C ${sx} ${sy + k}, ${tx} ${ty - k}, ${tx} ${ty}`;
    
    const type = edge.type || 'imports';
    const color = EDGE_COLORS[type] || EDGE_COLORS.imports;
    
    const related = state.selectedId && (edge.from === state.selectedId || edge.to === state.selectedId);
    const faded = state.selectedId && !related;
    
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('opacity', faded ? '0.2' : '0.95');
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathStr);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', related ? '3' : '2');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('marker-end', `url(#arrow-${type})`);
    
    const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
    title.textContent = `${edge.from} ‚Üí ${edge.to} (${type})`;
    path.appendChild(title);
    
    g.appendChild(path);
    
    if (related && !faded) {
      const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      dot.setAttribute('r', '4');
      dot.setAttribute('fill', color);
      const anim = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
      anim.setAttribute('dur', '2s');
      anim.setAttribute('repeatCount', 'indefinite');
      anim.setAttribute('path', pathStr);
      dot.appendChild(anim);
      g.appendChild(dot);
    }
    
    svg.appendChild(g);
    drawn++;
  }
  
  console.log(`‚úÖ Rendered ${drawn} edges`);
}

function updateMinimap() {
  if (!state.nodesReady || state.nodes.length === 0) return; // ‚úÖ Check ready flag
  
  const minimapSvg = document.getElementById('minimapSvg');
  minimapSvg.innerHTML = '';
  
  const bounds = {
    minX: Math.min(...state.nodes.map(n => n.x)),
    minY: Math.min(...state.nodes.map(n => n.y)),
    maxX: Math.max(...state.nodes.map(n => n.x + (state.nodeSizes.get(n.id)?.w || 280))),
    maxY: Math.max(...state.nodes.map(n => n.y + (state.nodeSizes.get(n.id)?.h || 150)))
  };
  
  const width = bounds.maxX - bounds.minX;
  const height = bounds.maxY - bounds.minY;
  
  minimapSvg.setAttribute('viewBox', `${bounds.minX} ${bounds.minY} ${width} ${height}`);
  
  state.nodes.forEach(node => {
    const size = state.nodeSizes.get(node.id) || { w: 280, h: 150 };
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', node.x);
    rect.setAttribute('y', node.y);
    rect.setAttribute('width', size.w);
    rect.setAttribute('height', size.h);
    rect.setAttribute('fill', node.id === state.selectedId ? '#667eea' : '#cbd5e1');
    rect.setAttribute('rx', '6');
    rect.classList.add('minimap-node');
    rect.addEventListener('click', () => focusNode(node.id));
    minimapSvg.appendChild(rect);
  });
  
  const canvas = document.getElementById('canvas');
  const vp = {
    x: -state.viewX / state.zoom,
    y: -state.viewY / state.zoom,
    w: canvas.clientWidth / state.zoom,
    h: canvas.clientHeight / state.zoom
  };
  
  const vpRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  vpRect.setAttribute('x', vp.x);
  vpRect.setAttribute('y', vp.y);
  vpRect.setAttribute('width', vp.w);
  vpRect.setAttribute('height', vp.h);
  vpRect.classList.add('minimap-viewport');
  minimapSvg.appendChild(vpRect);
}

let dragState = null;

function startDrag(event, node) {
  const canvas = document.getElementById('canvas');
  const rect = canvas.getBoundingClientRect();
  const mouseX = (event.clientX - rect.left - state.viewX) / state.zoom;
  const mouseY = (event.clientY - rect.top - state.viewY) / state.zoom;
  
  dragState = {
    node,
    offsetX: mouseX - node.x,
    offsetY: mouseY - node.y
  };
  
  document.addEventListener('mousemove', onDrag);
  document.addEventListener('mouseup', stopDrag);
}

function onDrag(event) {
  if (!dragState) return;
  
  const canvas = document.getElementById('canvas');
  const rect = canvas.getBoundingClientRect();
  const mouseX = (event.clientX - rect.left - state.viewX) / state.zoom;
  const mouseY = (event.clientY - rect.top - state.viewY) / state.zoom;
  
  dragState.node.x = Math.max(0, mouseX - dragState.offsetX);
  dragState.node.y = Math.max(0, mouseY - dragState.offsetY);
  
  const card = state.nodeElements.get(dragState.node.id);
  if (card) {
    card.style.transform = `translate(${dragState.node.x}px, ${dragState.node.y}px)`;
  }
  
  drawEdges();
  updateMinimap();
}

function stopDrag() {
  dragState = null;
  document.removeEventListener('mousemove', onDrag);
  document.removeEventListener('mouseup', stopDrag);
}

function selectNode(id) {
  state.selectedId = id;
  updateURL();
  
  const neighbors = new Set([id]);
  const inbound = [];
  const outbound = [];
  
  state.edges.forEach(edge => {
    if (edge.from === id) {
      neighbors.add(edge.to);
      outbound.push(edge.to);
    }
    if (edge.to === id) {
      neighbors.add(edge.from);
      inbound.push(edge.from);
    }
  });
  
  state.nodeElements.forEach((card, nodeId) => {
    card.classList.remove('selected', 'faded', 'highlighted');
    if (nodeId === id) {
      card.classList.add('selected');
    } else if (!neighbors.has(nodeId)) {
      card.classList.add('faded');
    }
  });
  
  const node = state.nodes.find(n => n.id === id);
  const details = document.getElementById('nodeDetails');
  
  const moduleDetail = state.moduleDetails[id] || {};
  const functions = moduleDetail.functions || [];
  const deadFunctions = moduleDetail.dead_functions || [];
  
  let functionsHtml = '';
  if (functions.length > 0) {
    functionsHtml = `
      <div class="node-detail" style="margin-top:12px;"><strong>Functions (${functions.length}):</strong></div>
      ${functions.map(f => `
        <div class="node-detail" style="margin-left:12px;font-size:12px;">
          <span style="color:${f.is_entrypoint ? '#10b981' : 'var(--text-medium)'}">
            ${f.is_entrypoint ? 'üöÄ' : '‚öôÔ∏è'} ${escapeHTML(f.name)}
          </span>
          ${f.complexity > 0 ? `<span style="color:var(--text-light)"> (complexity: ${f.complexity})</span>` : ''}
          ${f.calls.length > 0 ? `<br><span style="color:var(--text-light);margin-left:20px;">calls: ${f.calls.join(', ')}</span>` : ''}
        </div>
      `).join('')}
    `;
  }
  
  let deadCodeHtml = '';
  if (deadFunctions.length > 0) {
    deadCodeHtml = `
      <div class="node-detail" style="margin-top:12px;color:#ef4444;"><strong>‚ö†Ô∏è Dead Code (${deadFunctions.length}):</strong></div>
      <div class="chip-container">
        ${deadFunctions.map(fn => `<span class="chip" style="background:#fee2e2;border-color:#ef4444;">${escapeHTML(fn)}</span>`).join('')}
      </div>
    `;
  }
  
  details.innerHTML = `
    <div class="node-detail"><strong>ID:</strong> ${escapeHTML(node.id)}</div>
    <div class="node-detail"><strong>Kind:</strong> ${escapeHTML(node.kind || 'module')}</div>
    <div class="node-detail"><strong>Type:</strong> ${escapeHTML(node.type || 'data')}</div>
    <div class="node-detail"><strong>Path:</strong> ${escapeHTML(node.path || '‚Äî')}</div>
    ${node.parent ? `<div class="node-detail"><strong>Parent:</strong> ${escapeHTML(node.parent)}</div>` : ''}
    <div class="node-detail"><strong>Project:</strong> ${escapeHTML(node.project || '‚Äî')}</div>
    ${state.fileContents.has(node.path) ? `
      <button class="btn btn-primary" style="width:100%;margin-top:12px;" onclick="openCodeModal('${node.id}')">
        üìù View Source Code
      </button>
    ` : ''}
    ${functionsHtml}
    ${deadCodeHtml}
    <div class="node-detail" style="margin-top:12px;"><strong>Inbound (${inbound.length}):</strong></div>
    <div class="chip-container">
      ${inbound.map(nid => `<span class="chip" onclick="focusNode('${nid}')">${escapeHTML(nid.split('.').pop())}</span>`).join('') || '‚Äî'}
    </div>
    <div class="node-detail" style="margin-top:12px;"><strong>Outbound (${outbound.length}):</strong></div>
    <div class="chip-container">
      ${outbound.map(nid => `<span class="chip" onclick="focusNode('${nid}')">${escapeHTML(nid.split('.').pop())}</span>`).join('') || '‚Äî'}
    </div>
  `;
  
  drawEdges();
  updateMinimap();
}

function focusNode(id) {
  const node = state.nodes.find(n => n.id === id);
  if (!node) return;
  
  selectNode(id);
  
  const card = state.nodeElements.get(id);
  if (card) {
    card.classList.add('highlighted');
    setTimeout(() => card.classList.remove('highlighted'), 2000);
  }
  
  const size = state.nodeSizes.get(id) || { w: 280, h: 150 };
  const cx = node.x + size.w / 2;
  const cy = node.y + size.h / 2;
  
  const canvas = document.getElementById('canvas');
  const rect = canvas.getBoundingClientRect();
  
  state.viewX = rect.width / 2 - cx * state.zoom;
  state.viewY = rect.height / 2 - cy * state.zoom;
  applyViewport();
  updateURL();
}

function switchView(mode) {
  state.viewMode = mode;
  
  // Show/hide orientation selector for folder tree view
  const orientationWrapper = document.getElementById('orientationWrapper');
  if (mode === 'foldertree') {
    orientationWrapper.style.display = 'flex';
  } else {
    orientationWrapper.style.display = 'none';
  }
  
  updateURL();
  
  const layouts = {
    hierarchy: layoutHierarchy,
    folderhierarchy: layoutFolderHierarchy,
    grid: layoutGrid,
    force: layoutForce,
    swimlanes: layoutSwimlanes,
    radial: layoutRadial,
    foldertree: layoutFolderTree
  };
  
  const layoutFn = layouts[mode] || layoutGrid;
  layoutFn();
  
  drawEdges();
  updateMinimap();
  fitToScreen();
}

function updateOrientation(orientation) {
  state.orientation = orientation;
  updateURL();
  if (state.viewMode === 'foldertree') {
    layoutFolderTree();
    drawEdges();
    updateMinimap();
    fitToScreen();
  }
}

function layoutHierarchy() {
  const depth = window.layoutDepth || {};
  
  if (Object.keys(depth).length === 0) {
    layoutGrid();
    return;
  }
  
  const buckets = {};
  Object.entries(depth).forEach(([id, d]) => {
    if (!buckets[d]) buckets[d] = [];
    buckets[d].push(id);
  });
  
  const startX = 80;
  const startY = 80;
  const colGap = 320;
  const rowGap = 240;
  
  let row = 0;
  Object.keys(buckets).sort((a, b) => a - b).forEach(d => {
    buckets[d].forEach((id, i) => {
      const node = state.nodes.find(n => n.id === id);
      if (node) {
        node.x = startX + i * colGap;
        node.y = startY + row * rowGap;
        updateNodePosition(node);
      }
    });
    row++;
  });
}

function layoutFolderHierarchy() {
  // Group nodes by folder depth (path depth, not dependency depth)
  const folderDepth = new Map();
  
  state.nodes.forEach(node => {
    if (node.kind === 'external') {
      folderDepth.set(node.id, 999); // Put external at the end
    } else if (node.path) {
      // Calculate folder depth from path
      const depth = node.path.split('/').length - 1;
      folderDepth.set(node.id, depth);
    } else {
      folderDepth.set(node.id, 0);
    }
  });
  
  // Group by depth
  const buckets = {};
  folderDepth.forEach((depth, nodeId) => {
    if (!buckets[depth]) buckets[depth] = [];
    buckets[depth].push(nodeId);
  });
  
  const startX = 80;
  const startY = 80;
  const colGap = 320;
  const rowGap = 240;
  
  let row = 0;
  Object.keys(buckets).sort((a, b) => parseInt(a) - parseInt(b)).forEach(d => {
    // Sort nodes within each depth by folder path for grouping
    const sortedNodes = buckets[d].sort((a, b) => {
      const nodeA = state.nodes.find(n => n.id === a);
      const nodeB = state.nodes.find(n => n.id === b);
      if (!nodeA || !nodeB) return 0;
      return (nodeA.path || '').localeCompare(nodeB.path || '');
    });
    
    sortedNodes.forEach((id, i) => {
      const node = state.nodes.find(n => n.id === id);
      if (node) {
        node.x = startX + i * colGap;
        node.y = startY + row * rowGap;
        updateNodePosition(node);
      }
    });
    row++;
  });
}

function layoutGrid() {
  const cols = 5;
  const colGap = 320;
  const rowGap = 240;
  const start = 80;
  
  state.nodes.forEach((node, index) => {
    node.x = start + (index % cols) * colGap;
    node.y = start + Math.floor(index / cols) * rowGap;
    updateNodePosition(node);
  });
}

function layoutForce() {
  const seed = hashCode(state.nodes.map(n => n.id).sort().join(','));
  const rng = seededRandom(seed);
  
  const iterations = 150;
  const repulsion = 15000;
  const attraction = 0.01;
  const damping = 0.85;
  
  state.nodes.forEach(n => {
    n.x = rng() * 1600;
    n.y = rng() * 1200;
    n.vx = 0;
    n.vy = 0;
  });
  
  for (let iter = 0; iter < iterations; iter++) {
    for (let i = 0; i < state.nodes.length; i++) {
      for (let j = i + 1; j < state.nodes.length; j++) {
        const a = state.nodes[i];
        const b = state.nodes[j];
        
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        
        const force = repulsion / (dist * dist);
        const fx = (dx / dist) * force;
        const fy = (dy / dist) * force;
        
        a.vx -= fx;
        a.vy -= fy;
        b.vx += fx;
        b.vy += fy;
      }
    }
    
    state.edges.forEach(edge => {
      const from = state.nodes.find(n => n.id === edge.from);
      const to = state.nodes.find(n => n.id === edge.to);
      if (!from || !to) return;
      
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      
      const fx = dx * attraction;
      const fy = dy * attraction;
      
      from.vx += fx;
      from.vy += fy;
      to.vx -= fx;
      to.vy -= fy;
    });
    
    state.nodes.forEach(n => {
      n.x += n.vx;
      n.y += n.vy;
      n.vx *= damping;
      n.vy *= damping;
    });
  }
  
  state.nodes.forEach(updateNodePosition);
}

function layoutSwimlanes() {
  const groups = {};
  state.nodes.forEach(node => {
    const group = node.project || 'misc';
    if (!groups[group]) groups[group] = [];
    groups[group].push(node);
  });
  
  const keys = Object.keys(groups).sort();
  const canvas = document.getElementById('canvas');
  const height = canvas.clientHeight || 800;
  const laneHeight = Math.max(180, Math.floor((height - 120) / Math.max(1, keys.length)));
  
  const lanes = document.getElementById('lanes');
  lanes.innerHTML = '';
  
  keys.forEach((key, index) => {
    const lane = document.createElement('div');
    lane.className = 'lane';
    lane.style.top = (80 + index * laneHeight) + 'px';
    lane.style.height = (laneHeight - 40) + 'px';
    lane.textContent = '  ' + key;
    lanes.appendChild(lane);
  });
  
  const colGap = 300;
  const startX = 80;
  
  keys.forEach((key, index) => {
    groups[key].forEach((node, i) => {
      node.x = startX + i * colGap;
      node.y = 80 + index * laneHeight + 24;
      updateNodePosition(node);
    });
  });
}

function layoutRadial() {
  const depth = window.layoutDepth || {};
  const depthValues = [...new Set(Object.values(depth))];
  
  if (!depthValues.length) {
    layoutGrid();
    return;
  }
  
  const buckets = {};
  Object.entries(depth).forEach(([id, d]) => {
    if (!buckets[d]) buckets[d] = [];
    buckets[d].push(id);
  });
  
  const centerX = 900;
  const centerY = 550;
  const baseRadius = 140;
  const radiusStep = 180;
  
  depthValues.sort((a, b) => a - b).forEach((d, ringIndex) => {
    const ids = buckets[d];
    const radius = baseRadius + ringIndex * radiusStep;
    
    ids.forEach((id, i) => {
      const angle = (2 * Math.PI * i) / ids.length;
      const node = state.nodes.find(n => n.id === id);
      if (node) {
        node.x = centerX + radius * Math.cos(angle);
        node.y = centerY + radius * Math.sin(angle);
        updateNodePosition(node);
      }
    });
  });
}

function layoutFolderTree() {
  if (!state.folderStructure) {
    layoutGrid();
    return;
  }
  
  if (state.orientation === 'vertical') {
    layoutFolderTreeVertical();
  } else {
    layoutFolderTreeHorizontal();
  }
}

function layoutFolderTreeVertical() {
  const startX = 100;
  const startY = 80;
  const horizontalGap = 350;
  const verticalGap = 200;
  
  let currentY = startY;
  const depthMap = new Map();
  
  function processFolder(folder, depth = 0) {
    const x = startX + (depth * horizontalGap);
    
    // Position files in this folder
    (folder.files || []).forEach(file => {
      const node = state.nodes.find(n => n.path === file.path);
      if (node) {
        node.x = x;
        node.y = currentY;
        updateNodePosition(node);
        currentY += verticalGap;
        
        if (!depthMap.has(depth)) {
          depthMap.set(depth, []);
        }
        depthMap.get(depth).push(node);
      }
    });
    
    // Process subfolders
    Object.values(folder.children || {}).forEach(child => {
      processFolder(child, depth + 1);
    });
  }
  
  processFolder(state.folderStructure);
  
  // Center each depth column vertically
  depthMap.forEach((nodes, depth) => {
    if (nodes.length > 0) {
      const minY = Math.min(...nodes.map(n => n.y));
      const maxY = Math.max(...nodes.map(n => n.y));
      const centerOffset = (maxY - minY) / 2;
      
      nodes.forEach(node => {
        node.y = node.y - centerOffset + 300;
        updateNodePosition(node);
      });
    }
  });
}

function layoutFolderTreeHorizontal() {
  const startX = 80;
  const startY = 100;
  const horizontalGap = 350;
  const verticalGap = 200;
  
  let currentX = startX;
  const depthMap = new Map();
  
  function processFolder(folder, depth = 0) {
    const y = startY + (depth * verticalGap);
    
    // Position files in this folder
    (folder.files || []).forEach(file => {
      const node = state.nodes.find(n => n.path === file.path);
      if (node) {
        node.x = currentX;
        node.y = y;
        updateNodePosition(node);
        currentX += horizontalGap;
        
        if (!depthMap.has(depth)) {
          depthMap.set(depth, []);
        }
        depthMap.get(depth).push(node);
      }
    });
    
    // Process subfolders
    Object.values(folder.children || {}).forEach(child => {
      processFolder(child, depth + 1);
    });
  }
  
  processFolder(state.folderStructure);
  
  // Center each depth row horizontally
  depthMap.forEach((nodes, depth) => {
    if (nodes.length > 0) {
      const minX = Math.min(...nodes.map(n => n.x));
      const maxX = Math.max(...nodes.map(n => n.x));
      const centerOffset = (maxX - minX) / 2;
      
      nodes.forEach(node => {
        node.x = node.x - centerOffset + 500;
        updateNodePosition(node);
      });
    }
  });
}

function updateNodePosition(node) {
  const card = state.nodeElements.get(node.id);
  if (card) {
    card.style.transform = `translate(${node.x}px, ${node.y}px)`;
  }
}

function hashCode(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash);
}

function seededRandom(seed) {
  let state = seed;
  return function() {
    state = (state * 1664525 + 1013904223) % 4294967296;
    return state / 4294967296;
  };
}

function fitToScreen() {
  if (!state.nodes.length) return;
  
  const pad = 80;
  const boxes = state.nodes.map(n => {
    const size = state.nodeSizes.get(n.id) || { w: 280, h: 150 };
    return { x: n.x, y: n.y, w: size.w, h: size.h };
  });
  
  const minX = Math.min(...boxes.map(b => b.x));
  const minY = Math.min(...boxes.map(b => b.y));
  const maxX = Math.max(...boxes.map(b => b.x + b.w));
  const maxY = Math.max(...boxes.map(b => b.y + b.h));
  
  const canvas = document.getElementById('canvas');
  const scaleX = (canvas.clientWidth - pad * 2) / Math.max(1, maxX - minX);
  const scaleY = (canvas.clientHeight - pad * 2) / Math.max(1, maxY - minY);
  
  state.zoom = Math.max(0.2, Math.min(2.5, Math.min(scaleX, scaleY)));
  state.viewX = pad - minX * state.zoom;
  state.viewY = pad - minY * state.zoom;
  applyViewport();
  updateURL();
}

function zoomIn() {
  const canvas = document.getElementById('canvas');
  const rect = canvas.getBoundingClientRect();
  zoomAt(rect.width / 2, rect.height / 2, 1.25);
}

function zoomOut() {
  const canvas = document.getElementById('canvas');
  const rect = canvas.getBoundingClientRect();
  zoomAt(rect.width / 2, rect.height / 2, 1 / 1.25);
}

function zoomAt(cx, cy, factor) {
  const prevZoom = state.zoom;
  const nextZoom = Math.min(3, Math.max(0.2, prevZoom * factor));
  if (nextZoom === prevZoom) return;
  
  const vx = (cx - state.viewX) / prevZoom;
  const vy = (cy - state.viewY) / prevZoom;
  
  state.viewX = cx - vx * nextZoom;
  state.viewY = cy - vy * nextZoom;
  state.zoom = nextZoom;
  applyViewport();
  updateURL();
}

let panState = null;

document.getElementById('canvas').addEventListener('mousedown', event => {
  if (event.target.closest('.card') || event.target.closest('.minimap')) return;
  
  panState = {
    startX: event.clientX,
    startY: event.clientY,
    viewX: state.viewX,
    viewY: state.viewY
  };
  
  const onMove = e => {
    if (!panState) return;
    state.viewX = panState.viewX + (e.clientX - panState.startX);
    state.viewY = panState.viewY + (e.clientY - panState.startY);
    applyViewport();
  };
  
  const onUp = () => {
    panState = null;
    updateURL();
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
  };
  
  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
});

document.getElementById('canvas').addEventListener('wheel', event => {
  if (!(event.ctrlKey || event.metaKey)) return;
  event.preventDefault();
  
  const factor = event.deltaY < 0 ? 1.15 : 1 / 1.15;
  zoomAt(event.clientX, event.clientY, factor);
}, { passive: false });

function generateAIPrompt() {
  if (state.nodes.length === 0) {
    showToast('Upload a project first');
    return;
  }
  
  let prompt = `# Project Architecture Overview\n\n`;
  prompt += `**Total Modules:** ${state.nodes.filter(n => n.kind === 'module').length}\n`;
  prompt += `**Total Dependencies:** ${state.edges.length}\n\n`;
  
  if (state.folderStructure) {
    prompt += `## Folder Structure\n\n`;
    function printFolder(folder, prefix = '') {
      let result = '';
      Object.values(folder.children || {}).forEach(child => {
        result += `${prefix}üìÅ ${child.name}/\n`;
        result += printFolder(child, prefix + '  ');
      });
      (folder.files || []).forEach(file => {
        result += `${prefix}üìÑ ${file.name}\n`;
      });
      return result;
    }
    prompt += printFolder(state.folderStructure);
    prompt += '\n';
  }
  
  prompt += `## Module Details\n\n`;
  
  Object.entries(state.moduleDetails).forEach(([moduleId, details]) => {
    prompt += `### ${moduleId}\n`;
    prompt += `- **Type:** ${details.type}\n`;
    prompt += `- **Path:** ${details.path}\n`;
    prompt += `- **Role:** ${details.role}\n`;
    
    if (details.functions && details.functions.length > 0) {
      prompt += `- **Functions:**\n`;
      details.functions.forEach(fn => {
        prompt += `  - ${fn.name} (complexity: ${fn.complexity}, entrypoint: ${fn.is_entrypoint})\n`;
        if (fn.calls.length > 0) {
          prompt += `    - Calls: ${fn.calls.join(', ')}\n`;
        }
        if (fn.called_by.length > 0) {
          prompt += `    - Called by: ${fn.called_by.join(', ')}\n`;
        }
      });
    }
    
    if (details.entrypoints && details.entrypoints.length > 0) {
      prompt += `- **Entrypoints:** ${details.entrypoints.join(', ')}\n`;
    }
    
    if (details.dead_functions && details.dead_functions.length > 0) {
      prompt += `- **‚ö†Ô∏è Dead Code:** ${details.dead_functions.join(', ')}\n`;
    }
    
    prompt += `\n`;
  });
  
  prompt += `## Dependency Graph\n\n`;
  state.edges.forEach(edge => {
    prompt += `- \`${edge.from}\` ${edge.type === 'imports' ? '‚Üí' : '‚üπ'} \`${edge.to}\` (${edge.type})\n`;
  });
  
  navigator.clipboard.writeText(prompt).then(() => {
    showToast('AI-ready prompt copied!');
  }).catch(() => {
    console.log('Prompt:', prompt);
    showToast('Prompt generated (check console)');
  });
}

function exportScreenshot() {
  showToast('Screenshot: Use browser print to PDF or screenshot tool');
}

function cycleNeighbor(direction) {
  if (!state.selectedId) return;
  
  const neighbors = [];
  state.edges.forEach(edge => {
    if (edge.from === state.selectedId) neighbors.push(edge.to);
    if (edge.to === state.selectedId) neighbors.push(edge.from);
  });
  
  if (neighbors.length === 0) {
    showToast('No neighbors to cycle');
    return;
  }
  
  const currentIdx = neighbors.indexOf(state.selectedId);
  const nextIdx = (currentIdx + direction + neighbors.length) % neighbors.length;
  focusNode(neighbors[nextIdx]);
}

function exportGraph() {
  const exportData = {
    version: '4.7-fixed',
    generatedAt: new Date().toISOString(),
    nodes: state.nodes.map(n => ({
      id: n.id,
      kind: n.kind || 'module',
      type: n.type,
      title: n.title,
      project: n.project,
      path: n.path,
      parent: n.parent,
      meta: {
        ...n.stats,
        content: n.content
      },
      position: { x: n.x, y: n.y }
    })),
    edges: state.edges.map(e => ({
      from: e.from,
      to: e.to,
      type: e.type || 'imports'
    })),
    module_details: state.moduleDetails,
    folder_structure: state.folderStructure,
    layout: {
      mode: state.viewMode,
      zoom: state.zoom,
      viewX: state.viewX,
      viewY: state.viewY
    }
  };
  
  const data = JSON.stringify(exportData, null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `dnaios_architecture_v4.7_fixed_${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  showToast('Graph exported!');
}

document.addEventListener('keydown', event => {
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
  
  switch(event.key) {
    case '+':
    case '=':
      event.preventDefault();
      zoomIn();
      break;
    case '-':
    case '_':
      event.preventDefault();
      zoomOut();
      break;
    case '0':
      event.preventDefault();
      fitToScreen();
      break;
    case 'f':
    case 'F':
      event.preventDefault();
      if (state.selectedId) focusNode(state.selectedId);
      break;
    case '/':
      event.preventDefault();
      document.getElementById('searchInput').focus();
      break;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
      event.preventDefault();
      const modes = ['hierarchy', 'folderhierarchy', 'grid', 'force', 'swimlanes', 'radial', 'foldertree'];
      switchView(modes[parseInt(event.key) - 1]);
      document.getElementById('viewMode').value = modes[parseInt(event.key) - 1];
      break;
    case '[':
      event.preventDefault();
      cycleNeighbor(-1);
      break;
    case ']':
      event.preventDefault();
      cycleNeighbor(1);
      break;
  }
});

window.addEventListener('hashchange', () => {
  if (state.nodes.length) decodeState();
});

initTheme();
applyViewport();

console.log('üß¨ DNAiOS Architecture Studio v4.7 - Enhanced');
console.log('‚úÖ Double RAF timing fix applied');
console.log('‚úÖ Silent early-return for drawEdges');
console.log('‚úÖ No more "Cannot draw edges" warnings');
console.log('‚úÖ Folder Tree view with vertical/horizontal orientation');
console.log('‚úÖ Monaco Code Editor with syntax highlighting');
console.log('‚úÖ AI Code Assistant (OpenAI/Claude/DNAiOS)');
console.log('‚úÖ NEW: Folder Hierarchy view - organizes by path depth');
console.log('Shortcuts: +/- (zoom), 0 (fit), F (focus), / (search), 1-7 (layouts), [ ] (neighbors)');
</script>
</body>
</html>
